!function () { try { var e = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {}, t = (new Error).stack; t && (e._sentryDebugIds = e._sentryDebugIds || {}, e._sentryDebugIds[t] = "18adfc74-72c7-4443-b126-41ae6c358bbb", e._sentryDebugIdIdentifier = "sentry-dbid-18adfc74-72c7-4443-b126-41ae6c358bbb") } catch (e) { } }(); var _global = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {}; _global.SENTRY_RELEASE = { id: "b199d6ec2d2a86d480ba0da2e145692554b27e9d" }, (() => { "use strict"; var e, t, n, r, o = { 20597: e => { const t = { generateIdentifier: function () { return Math.random().toString(36).substr(2, 10) } }; t.localCName = t.generateIdentifier(), t.splitLines = function (e) { return e.trim().split("\n").map((e => e.trim())) }, t.splitSections = function (e) { return e.split("\nm=").map(((e, t) => (t > 0 ? "m=" + e : e).trim() + "\r\n")) }, t.getDescription = function (e) { const n = t.splitSections(e); return n && n[0] }, t.getMediaSections = function (e) { const n = t.splitSections(e); return n.shift(), n }, t.matchPrefix = function (e, n) { return t.splitLines(e).filter((e => 0 === e.indexOf(n))) }, t.parseCandidate = function (e) { let t; t = 0 === e.indexOf("a=candidate:") ? e.substring(12).split(" ") : e.substring(10).split(" "); const n = { foundation: t[0], component: { 1: "rtp", 2: "rtcp" }[t[1]] || t[1], protocol: t[2].toLowerCase(), priority: parseInt(t[3], 10), ip: t[4], address: t[4], port: parseInt(t[5], 10), type: t[7] }; for (let e = 8; e < t.length; e += 2)switch (t[e]) { case "raddr": n.relatedAddress = t[e + 1]; break; case "rport": n.relatedPort = parseInt(t[e + 1], 10); break; case "tcptype": n.tcpType = t[e + 1]; break; case "ufrag": n.ufrag = t[e + 1], n.usernameFragment = t[e + 1]; break; default: void 0 === n[t[e]] && (n[t[e]] = t[e + 1]) }return n }, t.writeCandidate = function (e) { const t = []; t.push(e.foundation); const n = e.component; "rtp" === n ? t.push(1) : "rtcp" === n ? t.push(2) : t.push(n), t.push(e.protocol.toUpperCase()), t.push(e.priority), t.push(e.address || e.ip), t.push(e.port); const r = e.type; return t.push("typ"), t.push(r), "host" !== r && e.relatedAddress && e.relatedPort && (t.push("raddr"), t.push(e.relatedAddress), t.push("rport"), t.push(e.relatedPort)), e.tcpType && "tcp" === e.protocol.toLowerCase() && (t.push("tcptype"), t.push(e.tcpType)), (e.usernameFragment || e.ufrag) && (t.push("ufrag"), t.push(e.usernameFragment || e.ufrag)), "candidate:" + t.join(" ") }, t.parseIceOptions = function (e) { return e.substr(14).split(" ") }, t.parseRtpMap = function (e) { let t = e.substr(9).split(" "); const n = { payloadType: parseInt(t.shift(), 10) }; return t = t[0].split("/"), n.name = t[0], n.clockRate = parseInt(t[1], 10), n.channels = 3 === t.length ? parseInt(t[2], 10) : 1, n.numChannels = n.channels, n }, t.writeRtpMap = function (e) { let t = e.payloadType; void 0 !== e.preferredPayloadType && (t = e.preferredPayloadType); const n = e.channels || e.numChannels || 1; return "a=rtpmap:" + t + " " + e.name + "/" + e.clockRate + (1 !== n ? "/" + n : "") + "\r\n" }, t.parseExtmap = function (e) { const t = e.substr(9).split(" "); return { id: parseInt(t[0], 10), direction: t[0].indexOf("/") > 0 ? t[0].split("/")[1] : "sendrecv", uri: t[1] } }, t.writeExtmap = function (e) { return "a=extmap:" + (e.id || e.preferredId) + (e.direction && "sendrecv" !== e.direction ? "/" + e.direction : "") + " " + e.uri + "\r\n" }, t.parseFmtp = function (e) { const t = {}; let n; const r = e.substr(e.indexOf(" ") + 1).split(";"); for (let e = 0; e < r.length; e++)n = r[e].trim().split("="), t[n[0].trim()] = n[1]; return t }, t.writeFmtp = function (e) { let t = "", n = e.payloadType; if (void 0 !== e.preferredPayloadType && (n = e.preferredPayloadType), e.parameters && Object.keys(e.parameters).length) { const r = []; Object.keys(e.parameters).forEach((t => { void 0 !== e.parameters[t] ? r.push(t + "=" + e.parameters[t]) : r.push(t) })), t += "a=fmtp:" + n + " " + r.join(";") + "\r\n" } return t }, t.parseRtcpFb = function (e) { const t = e.substr(e.indexOf(" ") + 1).split(" "); return { type: t.shift(), parameter: t.join(" ") } }, t.writeRtcpFb = function (e) { let t = "", n = e.payloadType; return void 0 !== e.preferredPayloadType && (n = e.preferredPayloadType), e.rtcpFeedback && e.rtcpFeedback.length && e.rtcpFeedback.forEach((e => { t += "a=rtcp-fb:" + n + " " + e.type + (e.parameter && e.parameter.length ? " " + e.parameter : "") + "\r\n" })), t }, t.parseSsrcMedia = function (e) { const t = e.indexOf(" "), n = { ssrc: parseInt(e.substr(7, t - 7), 10) }, r = e.indexOf(":", t); return r > -1 ? (n.attribute = e.substr(t + 1, r - t - 1), n.value = e.substr(r + 1)) : n.attribute = e.substr(t + 1), n }, t.parseSsrcGroup = function (e) { const t = e.substr(13).split(" "); return { semantics: t.shift(), ssrcs: t.map((e => parseInt(e, 10))) } }, t.getMid = function (e) { const n = t.matchPrefix(e, "a=mid:")[0]; if (n) return n.substr(6) }, t.parseFingerprint = function (e) { const t = e.substr(14).split(" "); return { algorithm: t[0].toLowerCase(), value: t[1].toUpperCase() } }, t.getDtlsParameters = function (e, n) { return { role: "auto", fingerprints: t.matchPrefix(e + n, "a=fingerprint:").map(t.parseFingerprint) } }, t.writeDtlsParameters = function (e, t) { let n = "a=setup:" + t + "\r\n"; return e.fingerprints.forEach((e => { n += "a=fingerprint:" + e.algorithm + " " + e.value + "\r\n" })), n }, t.parseCryptoLine = function (e) { const t = e.substr(9).split(" "); return { tag: parseInt(t[0], 10), cryptoSuite: t[1], keyParams: t[2], sessionParams: t.slice(3) } }, t.writeCryptoLine = function (e) { return "a=crypto:" + e.tag + " " + e.cryptoSuite + " " + ("object" == typeof e.keyParams ? t.writeCryptoKeyParams(e.keyParams) : e.keyParams) + (e.sessionParams ? " " + e.sessionParams.join(" ") : "") + "\r\n" }, t.parseCryptoKeyParams = function (e) { if (0 !== e.indexOf("inline:")) return null; const t = e.substr(7).split("|"); return { keyMethod: "inline", keySalt: t[0], lifeTime: t[1], mkiValue: t[2] ? t[2].split(":")[0] : void 0, mkiLength: t[2] ? t[2].split(":")[1] : void 0 } }, t.writeCryptoKeyParams = function (e) { return e.keyMethod + ":" + e.keySalt + (e.lifeTime ? "|" + e.lifeTime : "") + (e.mkiValue && e.mkiLength ? "|" + e.mkiValue + ":" + e.mkiLength : "") }, t.getCryptoParameters = function (e, n) { return t.matchPrefix(e + n, "a=crypto:").map(t.parseCryptoLine) }, t.getIceParameters = function (e, n) { const r = t.matchPrefix(e + n, "a=ice-ufrag:")[0], o = t.matchPrefix(e + n, "a=ice-pwd:")[0]; return r && o ? { usernameFragment: r.substr(12), password: o.substr(10) } : null }, t.writeIceParameters = function (e) { let t = "a=ice-ufrag:" + e.usernameFragment + "\r\na=ice-pwd:" + e.password + "\r\n"; return e.iceLite && (t += "a=ice-lite\r\n"), t }, t.parseRtpParameters = function (e) { const n = { codecs: [], headerExtensions: [], fecMechanisms: [], rtcp: [] }, r = t.splitLines(e)[0].split(" "); for (let o = 3; o < r.length; o++) { const i = r[o], a = t.matchPrefix(e, "a=rtpmap:" + i + " ")[0]; if (a) { const r = t.parseRtpMap(a), o = t.matchPrefix(e, "a=fmtp:" + i + " "); switch (r.parameters = o.length ? t.parseFmtp(o[0]) : {}, r.rtcpFeedback = t.matchPrefix(e, "a=rtcp-fb:" + i + " ").map(t.parseRtcpFb), n.codecs.push(r), r.name.toUpperCase()) { case "RED": case "ULPFEC": n.fecMechanisms.push(r.name.toUpperCase()) } } } return t.matchPrefix(e, "a=extmap:").forEach((e => { n.headerExtensions.push(t.parseExtmap(e)) })), n }, t.writeRtpDescription = function (e, n) { let r = ""; r += "m=" + e + " ", r += n.codecs.length > 0 ? "9" : "0", r += " UDP/TLS/RTP/SAVPF ", r += n.codecs.map((e => void 0 !== e.preferredPayloadType ? e.preferredPayloadType : e.payloadType)).join(" ") + "\r\n", r += "c=IN IP4 0.0.0.0\r\n", r += "a=rtcp:9 IN IP4 0.0.0.0\r\n", n.codecs.forEach((e => { r += t.writeRtpMap(e), r += t.writeFmtp(e), r += t.writeRtcpFb(e) })); let o = 0; return n.codecs.forEach((e => { e.maxptime > o && (o = e.maxptime) })), o > 0 && (r += "a=maxptime:" + o + "\r\n"), n.headerExtensions && n.headerExtensions.forEach((e => { r += t.writeExtmap(e) })), r }, t.parseRtpEncodingParameters = function (e) { const n = [], r = t.parseRtpParameters(e), o = -1 !== r.fecMechanisms.indexOf("RED"), i = -1 !== r.fecMechanisms.indexOf("ULPFEC"), a = t.matchPrefix(e, "a=ssrc:").map((e => t.parseSsrcMedia(e))).filter((e => "cname" === e.attribute)), s = a.length > 0 && a[0].ssrc; let c; const d = t.matchPrefix(e, "a=ssrc-group:FID").map((e => e.substr(17).split(" ").map((e => parseInt(e, 10))))); d.length > 0 && d[0].length > 1 && d[0][0] === s && (c = d[0][1]), r.codecs.forEach((e => { if ("RTX" === e.name.toUpperCase() && e.parameters.apt) { let t = { ssrc: s, codecPayloadType: parseInt(e.parameters.apt, 10) }; s && c && (t.rtx = { ssrc: c }), n.push(t), o && (t = JSON.parse(JSON.stringify(t)), t.fec = { ssrc: s, mechanism: i ? "red+ulpfec" : "red" }, n.push(t)) } })), 0 === n.length && s && n.push({ ssrc: s }); let p = t.matchPrefix(e, "b="); return p.length && (p = 0 === p[0].indexOf("b=TIAS:") ? parseInt(p[0].substr(7), 10) : 0 === p[0].indexOf("b=AS:") ? 1e3 * parseInt(p[0].substr(5), 10) * .95 - 16e3 : void 0, n.forEach((e => { e.maxBitrate = p }))), n }, t.parseRtcpParameters = function (e) { const n = {}, r = t.matchPrefix(e, "a=ssrc:").map((e => t.parseSsrcMedia(e))).filter((e => "cname" === e.attribute))[0]; r && (n.cname = r.value, n.ssrc = r.ssrc); const o = t.matchPrefix(e, "a=rtcp-rsize"); n.reducedSize = o.length > 0, n.compound = 0 === o.length; const i = t.matchPrefix(e, "a=rtcp-mux"); return n.mux = i.length > 0, n }, t.writeRtcpParameters = function (e) { let t = ""; return e.reducedSize && (t += "a=rtcp-rsize\r\n"), e.mux && (t += "a=rtcp-mux\r\n"), void 0 !== e.ssrc && e.cname && (t += "a=ssrc:" + e.ssrc + " cname:" + e.cname + "\r\n"), t }, t.parseMsid = function (e) { let n; const r = t.matchPrefix(e, "a=msid:"); if (1 === r.length) return n = r[0].substr(7).split(" "), { stream: n[0], track: n[1] }; const o = t.matchPrefix(e, "a=ssrc:").map((e => t.parseSsrcMedia(e))).filter((e => "msid" === e.attribute)); return o.length > 0 ? (n = o[0].value.split(" "), { stream: n[0], track: n[1] }) : void 0 }, t.parseSctpDescription = function (e) { const n = t.parseMLine(e), r = t.matchPrefix(e, "a=max-message-size:"); let o; r.length > 0 && (o = parseInt(r[0].substr(19), 10)), isNaN(o) && (o = 65536); const i = t.matchPrefix(e, "a=sctp-port:"); if (i.length > 0) return { port: parseInt(i[0].substr(12), 10), protocol: n.fmt, maxMessageSize: o }; const a = t.matchPrefix(e, "a=sctpmap:"); if (a.length > 0) { const e = a[0].substr(10).split(" "); return { port: parseInt(e[0], 10), protocol: e[1], maxMessageSize: o } } }, t.writeSctpDescription = function (e, t) { let n = []; return n = "DTLS/SCTP" !== e.protocol ? ["m=" + e.kind + " 9 " + e.protocol + " " + t.protocol + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctp-port:" + t.port + "\r\n"] : ["m=" + e.kind + " 9 " + e.protocol + " " + t.port + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctpmap:" + t.port + " " + t.protocol + " 65535\r\n"], void 0 !== t.maxMessageSize && n.push("a=max-message-size:" + t.maxMessageSize + "\r\n"), n.join("") }, t.generateSessionId = function () { return Math.random().toString().substr(2, 21) }, t.writeSessionBoilerplate = function (e, n, r) { let o; const i = void 0 !== n ? n : 2; return o = e || t.generateSessionId(), "v=0\r\no=" + (r || "thisisadapterortc") + " " + o + " " + i + " IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\n" }, t.getDirection = function (e, n) { const r = t.splitLines(e); for (let e = 0; e < r.length; e++)switch (r[e]) { case "a=sendrecv": case "a=sendonly": case "a=recvonly": case "a=inactive": return r[e].substr(2) }return n ? t.getDirection(n) : "sendrecv" }, t.getKind = function (e) { return t.splitLines(e)[0].split(" ")[0].substr(2) }, t.isRejected = function (e) { return "0" === e.split(" ", 2)[1] }, t.parseMLine = function (e) { const n = t.splitLines(e)[0].substr(2).split(" "); return { kind: n[0], port: parseInt(n[1], 10), protocol: n[2], fmt: n.slice(3).join(" ") } }, t.parseOLine = function (e) { const n = t.matchPrefix(e, "o=")[0].substr(2).split(" "); return { username: n[0], sessionId: n[1], sessionVersion: parseInt(n[2], 10), netType: n[3], addressType: n[4], address: n[5] } }, t.isValidSDP = function (e) { if ("string" != typeof e || 0 === e.length) return !1; const n = t.splitLines(e); for (let e = 0; e < n.length; e++)if (n[e].length < 2 || "=" !== n[e].charAt(1)) return !1; return !0 }, e.exports = t }, 65617: (e, t, n) => { n.d(t, { Au: () => o, ky: () => i }); var r = n(37166); const o = () => !1, i = (e, t) => { var n; return o() && null !== (n = (0, r.v)(window.location.search)[e]) && void 0 !== n ? n : t } }, 37166: (e, t, n) => { n.d(t, { v: () => r }); const r = (e = window.location.search) => e ? Object.fromEntries(new URLSearchParams(e).entries()) : {} } }, i = {}; function a(e) { var t = i[e]; if (void 0 !== t) return t.exports; var n = i[e] = { id: e, loaded: !1, exports: {} }; return o[e].call(n.exports, n, n.exports, a), n.loaded = !0, n.exports } a.m = o, a.amdD = function () { throw new Error("define cannot be used indirect") }, a.amdO = {}, a.n = e => { var t = e && e.__esModule ? () => e.default : () => e; return a.d(t, { a: t }), t }, t = Object.getPrototypeOf ? e => Object.getPrototypeOf(e) : e => e.__proto__, a.t = function (n, r) { if (1 & r && (n = this(n)), 8 & r) return n; if ("object" == typeof n && n) { if (4 & r && n.__esModule) return n; if (16 & r && "function" == typeof n.then) return n } var o = Object.create(null); a.r(o); var i = {}; e = e || [null, t({}), t([]), t(t)]; for (var s = 2 & r && n; "object" == typeof s && !~e.indexOf(s); s = t(s))Object.getOwnPropertyNames(s).forEach((e => i[e] = () => n[e])); return i.default = () => n, a.d(o, i), o }, a.d = (e, t) => { for (var n in t) a.o(t, n) && !a.o(e, n) && Object.defineProperty(e, n, { enumerable: !0, get: t[n] }) }, a.f = {}, a.e = e => Promise.all(Object.keys(a.f).reduce(((t, n) => (a.f[n](e, t), t)), [])), a.u = e => "js/" + e + "_prod_" + { 89: "d5039cf1e0ab13dc4fad", 117: "bd04fa14e38b85425047", 147: "0c6f14f4e92880262879", 274: "cfcb0bba690f4eb78ff2", 462: "04f2eb0684fad99c9529", 467: "77b932a68eb2668edf26", 486: "e376e5f9ed6f8307d11a", 557: "2992aa4ad884accbc81b", 558: "aa0ce5306677c0577ff9", 560: "46fd8cd07e1ec39c5099", 573: "83645ac96452290f6f39", 593: "ac8d1644086e671c6d99", 595: "39d984db26c306cb317b", 669: "dd03a4d1240870eb59a4", 848: "8fe670a369bd73ff9b96", 851: "6215c14b527cf2e14968", 935: "255d3dcb6444e9c2b800", 1077: "a24478f5d2412b3b648e", 1126: "c365bddb56025af8442f", 1134: "64f0c761b2e09583df8a", 1157: "a4cdd824242d8c47882a", 1175: "87aa2b029a1116760471", 1186: "67ed8875d5db87e3cf63", 1220: "e10faf6eed6c4310bc62", 1367: "9f31882a415e02c824d5", 1414: "665b636c3eb96a79429d", 1416: "ecc58a6b5b07643227d7", 1428: "c80395ce914da9263628", 1486: "30373c0d07139e0e76a6", 1498: "e5e54f0c8e69318a1440", 1516: "d8abbf8cb90de9d07619", 1531: "576e3986cbb2a0e15c02", 1597: "9046ae30221d887383ec", 1608: "af21febee540e5a6d635", 1644: "469b44109714d11ec4f0", 1661: "5ebb266a73fb205af5cf", 1662: "ee035f4f965ca350b3d2", 1721: "b3c0f94958a4a00c7b82", 1745: "4297320d1342b3d41479", 1750: "baeece3ce2909d8de467", 1806: "5f6fa4058f9b602155ca", 1837: "30242f395ab9a3f9f252", 1996: "8812aae4105c464376a7", 2047: "c813e1d768eff0c45287", 2055: "9bbd2cb36bfce7389d71", 2104: "118a60c6c68bdcdeb85b", 2113: "0713db6cfd02518cd68d", 2241: "18c1403cab056b58c568", 2289: "4057f5319128be021d86", 2344: "ed4a5868aa863f5c64e6", 2423: "eb1d65627a75054608e7", 2588: "bdae09904c21715dcbb9", 2640: "7856c06266f2b5b23b32", 2733: "5ab5aef6873db1435671", 2785: "279b74a13c0b9936648c", 2814: "3ddae41ed36070ce2c50", 2829: "c0358962056336cdad99", 2850: "b8c7fd1d0f6c1d1fe48d", 2906: "5f6d8a496b42401375af", 2919: "6c45c71f578384b5923f", 2950: "9b32407b04d466c551b2", 2983: "cca52c13ef0e083e0bd8", 3032: "7a882642c265f2b2b8e4", 3056: "25ca4eb0536d59e5a20b", 3064: "c08ecd7c5ffb8ec5918a", 3110: "f908b6c57c54253f27b2", 3136: "a22c1bafcc8becee9e3e", 3245: "c04d91fffb18db3db766", 3330: "38fb84b933c8a47723c4", 3409: "33ae80cfd429409d09f9", 3527: "b86ca27ed947ee50b840", 3538: "731aedd730b3683b2867", 3580: "3678a0e511575601f9d6", 3617: "aaee91d23b2e41b824dd", 3635: "1c5adde207c0177b17eb", 3659: "55c7402fb46031b8558b", 3680: "033956707b3794dd4a68", 3685: "5ae637691bbc2a03b145", 3691: "011db33b5f26c0affdd1", 3737: "7ab97ff198f5352858ef", 3840: "f8ca31dcd1e75fe69845", 3955: "49bdfeaa4be6256a9e7d", 3964: "49842929156325250050", 3965: "d7c163bad3a26f23c66a", 3969: "cc8cd187e33f87f4b1fe", 3986: "577b28c25d6114686593", 4014: "96b62826942bc8f59edc", 4033: "abaadc015270a6e8f4b6", 4087: "0c85611aa0f94cacee91", 4135: "3b846a9c18c07651cd61", 4289: "70ffd25d9926340e563f", 4324: "34c5417bab9f65fea6ab", 4406: "8e597e36795ca3219701", 4492: "734dd638778e8cf3757e", 4569: "aa2d5e666b076922e548", 4574: "f5cc0cc75b2c05209595", 4575: "873b685a30025b29d40c", 4767: "ed0319d1d0983a37f6df", 4803: "547af37b6a4245b4cdff", 4883: "9ad08513207c2a989d1e", 5054: "f48fd2f45536a34723b8", 5072: "c68858e2fb704454eeb4", 5193: "2e84ada5ff34999f53fb", 5214: "f836bfdc3f08cf7d4521", 5253: "5555da7ca17d39a6fdb4", 5281: "1f0220335949c8b59565", 5310: "4f89b68384ae6d937755", 5327: "4d5f2fd21c104db50b2b", 5349: "033440c951f9fef88a17", 5509: "518f0b749bc92ac58574", 5521: "ab5654934ec85ddfe8ca", 5543: "66d0899e8a3d803eae0d", 5558: "40218d0c7e31504990e3", 5561: "9fa4c627b2b1a4462cea", 5607: "75b03a581e2b772e1cd0", 5643: "ca567337c6d40de83f8e", 5812: "705f3ad46969c4d86afe", 5836: "0b7af11eaa1914553396", 5855: "950c8d485b9204d2f76d", 5875: "fa98a01ec454a0547410", 5926: "959c03381ee7a75462f3", 6068: "219b7c6549c72a03a415", 6085: "794df5453e400989de24", 6092: "a08cac5873674b5160c7", 6123: "7ea44073f003ed77762d", 6135: "ebc22cf676b82122601c", 6155: "c4a2e55f04bea41b25c9", 6296: "6a443280ca591c92033e", 6305: "5d53874f85ea14aeedcb", 6477: "5ca418dd62f9d6f611b8", 6551: "3f072859268e01108c41", 6562: "d264d350d7fd21e771ea", 6576: "e92e3e9fa0a148f5c5fd", 6582: "e45be9057d4fdc69c26b", 6683: "caa19a4264cbd4aa7a2b", 6706: "87e8cb2298cf956ae6fa", 6748: "1c0e6625b995c476d7dc", 6793: "a9b9dc5d0312eab8fc52", 6937: "745e3b8fd3b6524270ce", 7011: "47e9e40c128a50c15619", 7035: "dadd03c63e847b40666f", 7041: "6771a6459db5fd0c6b91", 7071: "920de4ab2ae6d1a59f67", 7077: "db0eca2f963d718111c3", 7126: "1bf3c720821654f07087", 7137: "4595dfed4d8eb68fe55c", 7171: "eccd88aff09677aec5af", 7218: "04f72762983b4817bc4d", 7422: "a67d57325165a8db7235", 7446: "c5253f03792602e19790", 7549: "17d109ddb237b800bac8", 7598: "be4def5498c5b73e0130", 7621: "f59c14dde3ecd83c63dd", 7660: "fe36dbd0e63d1da635db", 7686: "80c74a06edc38e69263b", 7716: "df181122d50bdb1839ae", 7803: "300aa2928cc32d37366e", 7905: "4b59dcf20bc75acf76cf", 7960: "c2caee1f5f074cee7e08", 7979: "fc78a3f0f134a185562e", 8053: "5c0c2cf19de4a52c13b7", 8055: "4fd57024ba5ce789d446", 8090: "c8882cb135d8fc6aa5ea", 8208: "7fa1c5814faff3714c8e", 8282: "9f7d964351fea69c834f", 8439: "3222fdf4748eac841f1e", 8450: "5017e1e61f1e014333fd", 8470: "62b9e2c3c3b8a3a519b9", 8473: "80ace7eee5f87e08187c", 8648: "33a644b3ab52b6bb7753", 8727: "a966d81033d551d67f44", 8880: "a6ca39fbb17f5cb11b86", 8928: "83decac97d1ffddeb723", 8949: "74587ad38255d642ca41", 9077: "89ce065f73fe7e019d21", 9089: "4d5a45b21d6edf8cc5f6", 9154: "2de4e5523d7a6daee53c", 9314: "9046c4d88bbc5a3aa4ad", 9461: "6d278dde4cbd36bc10ba", 9481: "693eb78af440d31f56c1", 9827: "0c7fae5c5c1e871618cb", 9901: "59ae16382e5dcd89b8a9" }[e] + ".js", a.miniCssF = e => "css/" + e + "_prod_" + { 573: "15d800f57f460c235c6c", 1721: "98a669e3fd56635fe3d6", 1806: "00c43acc7a0f2125d731", 2733: "e7439403182c06bcfc11", 3330: "692725054d16b4670b58", 4014: "1751a9b5a9d0f73636b6", 4574: "7aa2254f94fae3f0a6b5", 5193: "d031210b1992f7fdf289", 9089: "8e534eabe9ca826600b4" }[e] + ".css", a.g = function () { if ("object" == typeof globalThis) return globalThis; try { return this || new Function("return this")() } catch (e) { if ("object" == typeof window) return window } }(), a.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), n = {}, r = "duolingo-english-test-deployment:", a.l = (e, t, o, i) => { if (n[e]) n[e].push(t); else { var s, c; if (void 0 !== o) for (var d = document.getElementsByTagName("script"), p = 0; p < d.length; p++) { var f = d[p]; if (f.getAttribute("src") == e || f.getAttribute("data-webpack") == r + o) { s = f; break } } s || (c = !0, (s = document.createElement("script")).charset = "utf-8", s.timeout = 120, a.nc && s.setAttribute("nonce", a.nc), s.setAttribute("data-webpack", r + o), s.src = e), n[e] = [t]; var l = (t, r) => { s.onerror = s.onload = null, clearTimeout(u); var o = n[e]; if (delete n[e], s.parentNode && s.parentNode.removeChild(s), o && o.forEach((e => e(r))), t) return t(r) }, u = setTimeout(l.bind(null, void 0, { type: "timeout", target: s }), 12e4); s.onerror = l.bind(null, s.onerror), s.onload = l.bind(null, s.onload), c && document.head.appendChild(s) } }, a.r = e => { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 }) }, a.nmd = e => (e.paths = [], e.children || (e.children = []), e), (() => { var e; a.g.importScripts && (e = a.g.location + ""); var t = a.g.document; if (!e && t && (t.currentScript && (e = t.currentScript.src), !e)) { var n = t.getElementsByTagName("script"); if (n.length) for (var r = n.length - 1; r > -1 && !e;)e = n[r--].src } if (!e) throw new Error("Automatic publicPath is not supported in this browser"); e = e.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/"), a.p = e + "../" })(), (() => { if ("undefined" != typeof document) { var e = { 179: 0 }; a.f.miniCss = (t, n) => { e[t] ? n.push(e[t]) : 0 !== e[t] && { 573: 1, 1721: 1, 1806: 1, 2733: 1, 3330: 1, 4014: 1, 4574: 1, 5193: 1, 9089: 1 }[t] && n.push(e[t] = (e => new Promise(((t, n) => { var r = a.miniCssF(e), o = a.p + r; if (((e, t) => { for (var n = document.getElementsByTagName("link"), r = 0; r < n.length; r++) { var o = (a = n[r]).getAttribute("data-href") || a.getAttribute("href"); if ("stylesheet" === a.rel && (o === e || o === t)) return a } var i = document.getElementsByTagName("style"); for (r = 0; r < i.length; r++) { var a; if ((o = (a = i[r]).getAttribute("data-href")) === e || o === t) return a } })(r, o)) return t(); ((e, t, n, r, o) => { var i = document.createElement("link"); i.rel = "stylesheet", i.type = "text/css", i.onerror = i.onload = n => { if (i.onerror = i.onload = null, "load" === n.type) r(); else { var a = n && ("load" === n.type ? "missing" : n.type), s = n && n.target && n.target.href || t, c = new Error("Loading CSS chunk " + e + " failed.\n(" + s + ")"); c.code = "CSS_CHUNK_LOAD_FAILED", c.type = a, c.request = s, i.parentNode.removeChild(i), o(c) } }, i.href = t, document.head.appendChild(i) })(e, o, 0, t, n) })))(t).then((() => { e[t] = 0 }), (n => { throw delete e[t], n }))) } } })(), (() => { var e = { 179: 0 }; a.f.j = (t, n) => { var r = a.o(e, t) ? e[t] : void 0; if (0 !== r) if (r) n.push(r[2]); else { var o = new Promise(((n, o) => r = e[t] = [n, o])); n.push(r[2] = o); var i = a.p + a.u(t), s = new Error; a.l(i, (n => { if (a.o(e, t) && (0 !== (r = e[t]) && (e[t] = void 0), r)) { var o = n && ("load" === n.type ? "missing" : n.type), i = n && n.target && n.target.src; s.message = "Loading chunk " + t + " failed.\n(" + o + ": " + i + ")", s.name = "ChunkLoadError", s.type = o, s.request = i, r[1](s) } }), "chunk-" + t, t) } }; var t = (t, n) => { var r, o, [i, s, c] = n, d = 0; if (i.some((t => 0 !== e[t]))) { for (r in s) a.o(s, r) && (a.m[r] = s[r]); c && c(a) } for (t && t(n); d < i.length; d++)o = i[d], a.o(e, o) && e[o] && e[o][0](), e[o] = 0 }, n = self.webpackChunkduolingo_english_test_deployment = self.webpackChunkduolingo_english_test_deployment || []; n.forEach(t.bind(null, 0)), n.push = t.bind(null, n.push.bind(n)) })(), (() => { var e = {}; a.r(e), a.d(e, { fixNegotiationNeeded: () => x, shimAddTrackRemoveTrack: () => w, shimAddTrackRemoveTrackWithNative: () => k, shimGetDisplayMedia: () => v, shimGetSendersWithDtmf: () => R, shimGetStats: () => P, shimGetUserMedia: () => g, shimMediaStream: () => T, shimOnTrack: () => S, shimPeerConnection: () => E, shimSenderReceiverGetStats: () => _ }); var t = {}; a.r(t), a.d(t, { shimAddTransceiver: () => F, shimCreateAnswer: () => G, shimCreateOffer: () => z, shimGetDisplayMedia: () => M, shimGetParameters: () => U, shimGetUserMedia: () => D, shimOnTrack: () => O, shimPeerConnection: () => I, shimRTCDataChannel: () => N, shimReceiverGetStats: () => L, shimRemoveStream: () => A, shimSenderGetStats: () => j }); var n = {}; a.r(n), a.d(n, { shimAudioContext: () => Y, shimCallbacksAPI: () => B, shimConstraints: () => W, shimCreateOfferLegacy: () => H, shimGetUserMedia: () => K, shimLocalStreamsAPI: () => J, shimRTCIceServerUrls: () => $, shimRemoteStreamsAPI: () => V, shimTrackEventTransceiver: () => q }); var r = {}; a.r(r), a.d(r, { removeExtmapAllowMixed: () => oe, shimAddIceCandidateNullOrEmpty: () => ie, shimConnectionState: () => re, shimMaxMessageSize: () => te, shimParameterlessSetLocalDescription: () => ae, shimRTCIceCandidate: () => Z, shimRTCIceCandidateRelayProtocol: () => ee, shimSendThrowTypeError: () => ne }); var o = a(65617); let i = !0, s = !0; function c(e, t, n) { const r = e.match(t); return r && r.length >= n && parseInt(r[n], 10) } function d(e, t, n) { if (!e.RTCPeerConnection) return; const r = e.RTCPeerConnection.prototype, o = r.addEventListener; r.addEventListener = function (e, r) { if (e !== t) return o.apply(this, arguments); const i = e => { const t = n(e); t && (r.handleEvent ? r.handleEvent(t) : r(t)) }; return this._eventMap = this._eventMap || {}, this._eventMap[t] || (this._eventMap[t] = new Map), this._eventMap[t].set(r, i), o.apply(this, [e, i]) }; const i = r.removeEventListener; r.removeEventListener = function (e, n) { if (e !== t || !this._eventMap || !this._eventMap[t]) return i.apply(this, arguments); if (!this._eventMap[t].has(n)) return i.apply(this, arguments); const r = this._eventMap[t].get(n); return this._eventMap[t].delete(n), 0 === this._eventMap[t].size && delete this._eventMap[t], 0 === Object.keys(this._eventMap).length && delete this._eventMap, i.apply(this, [e, r]) }, Object.defineProperty(r, "on" + t, { get() { return this["_on" + t] }, set(e) { this["_on" + t] && (this.removeEventListener(t, this["_on" + t]), delete this["_on" + t]), e && this.addEventListener(t, this["_on" + t] = e) }, enumerable: !0, configurable: !0 }) } function p(e) { return "boolean" != typeof e ? new Error("Argument type: " + typeof e + ". Please use a boolean.") : (i = e, e ? "adapter.js logging disabled" : "adapter.js logging enabled") } function f(e) { return "boolean" != typeof e ? new Error("Argument type: " + typeof e + ". Please use a boolean.") : (s = !e, "adapter.js deprecation warnings " + (e ? "disabled" : "enabled")) } function l() { if ("object" == typeof window) { if (i) return; "undefined" != typeof console && "function" == typeof console.log && console.log.apply(console, arguments) } } function u(e, t) { s && console.warn(e + " is deprecated, please use " + t + " instead.") } function h(e) { return "[object Object]" === Object.prototype.toString.call(e) } function m(e) { return h(e) ? Object.keys(e).reduce((function (t, n) { const r = h(e[n]), o = r ? m(e[n]) : e[n], i = r && !Object.keys(o).length; return void 0 === o || i ? t : Object.assign(t, { [n]: o }) }), {}) : e } function b(e, t, n) { t && !n.has(t.id) && (n.set(t.id, t), Object.keys(t).forEach((r => { r.endsWith("Id") ? b(e, e.get(t[r]), n) : r.endsWith("Ids") && t[r].forEach((t => { b(e, e.get(t), n) })) }))) } function y(e, t, n) { const r = n ? "outbound-rtp" : "inbound-rtp", o = new Map; if (null === t) return o; const i = []; return e.forEach((e => { "track" === e.type && e.trackIdentifier === t.id && i.push(e) })), i.forEach((t => { e.forEach((n => { n.type === r && n.trackId === t.id && b(e, n, o) })) })), o } const C = l; function g(e, t) { const n = e && e.navigator; if (!n.mediaDevices) return; const r = function (e) { if ("object" != typeof e || e.mandatory || e.optional) return e; const t = {}; return Object.keys(e).forEach((n => { if ("require" === n || "advanced" === n || "mediaSource" === n) return; const r = "object" == typeof e[n] ? e[n] : { ideal: e[n] }; void 0 !== r.exact && "number" == typeof r.exact && (r.min = r.max = r.exact); const o = function (e, t) { return e ? e + t.charAt(0).toUpperCase() + t.slice(1) : "deviceId" === t ? "sourceId" : t }; if (void 0 !== r.ideal) { t.optional = t.optional || []; let e = {}; "number" == typeof r.ideal ? (e[o("min", n)] = r.ideal, t.optional.push(e), e = {}, e[o("max", n)] = r.ideal, t.optional.push(e)) : (e[o("", n)] = r.ideal, t.optional.push(e)) } void 0 !== r.exact && "number" != typeof r.exact ? (t.mandatory = t.mandatory || {}, t.mandatory[o("", n)] = r.exact) : ["min", "max"].forEach((e => { void 0 !== r[e] && (t.mandatory = t.mandatory || {}, t.mandatory[o(e, n)] = r[e]) })) })), e.advanced && (t.optional = (t.optional || []).concat(e.advanced)), t }, o = function (e, o) { if (t.version >= 61) return o(e); if ((e = JSON.parse(JSON.stringify(e))) && "object" == typeof e.audio) { const t = function (e, t, n) { t in e && !(n in e) && (e[n] = e[t], delete e[t]) }; t((e = JSON.parse(JSON.stringify(e))).audio, "autoGainControl", "googAutoGainControl"), t(e.audio, "noiseSuppression", "googNoiseSuppression"), e.audio = r(e.audio) } if (e && "object" == typeof e.video) { let i = e.video.facingMode; i = i && ("object" == typeof i ? i : { ideal: i }); const a = t.version < 66; if (i && ("user" === i.exact || "environment" === i.exact || "user" === i.ideal || "environment" === i.ideal) && (!n.mediaDevices.getSupportedConstraints || !n.mediaDevices.getSupportedConstraints().facingMode || a)) { let t; if (delete e.video.facingMode, "environment" === i.exact || "environment" === i.ideal ? t = ["back", "rear"] : "user" !== i.exact && "user" !== i.ideal || (t = ["front"]), t) return n.mediaDevices.enumerateDevices().then((n => { let a = (n = n.filter((e => "videoinput" === e.kind))).find((e => t.some((t => e.label.toLowerCase().includes(t))))); return !a && n.length && t.includes("back") && (a = n[n.length - 1]), a && (e.video.deviceId = i.exact ? { exact: a.deviceId } : { ideal: a.deviceId }), e.video = r(e.video), C("chrome: " + JSON.stringify(e)), o(e) })) } e.video = r(e.video) } return C("chrome: " + JSON.stringify(e)), o(e) }, i = function (e) { return t.version >= 64 ? e : { name: { PermissionDeniedError: "NotAllowedError", PermissionDismissedError: "NotAllowedError", InvalidStateError: "NotAllowedError", DevicesNotFoundError: "NotFoundError", ConstraintNotSatisfiedError: "OverconstrainedError", TrackStartError: "NotReadableError", MediaDeviceFailedDueToShutdown: "NotAllowedError", MediaDeviceKillSwitchOn: "NotAllowedError", TabCaptureError: "AbortError", ScreenCaptureError: "AbortError", DeviceCaptureError: "AbortError" }[e.name] || e.name, message: e.message, constraint: e.constraint || e.constraintName, toString() { return this.name + (this.message && ": ") + this.message } } }; if (n.getUserMedia = function (e, t, r) { o(e, (e => { n.webkitGetUserMedia(e, t, (e => { r && r(i(e)) })) })) }.bind(n), n.mediaDevices.getUserMedia) { const e = n.mediaDevices.getUserMedia.bind(n.mediaDevices); n.mediaDevices.getUserMedia = function (t) { return o(t, (t => e(t).then((e => { if (t.audio && !e.getAudioTracks().length || t.video && !e.getVideoTracks().length) throw e.getTracks().forEach((e => { e.stop() })), new DOMException("", "NotFoundError"); return e }), (e => Promise.reject(i(e)))))) } } } function v(e, t) { e.navigator.mediaDevices && "getDisplayMedia" in e.navigator.mediaDevices || e.navigator.mediaDevices && ("function" == typeof t ? e.navigator.mediaDevices.getDisplayMedia = function (n) { return t(n).then((t => { const r = n.video && n.video.width, o = n.video && n.video.height, i = n.video && n.video.frameRate; return n.video = { mandatory: { chromeMediaSource: "desktop", chromeMediaSourceId: t, maxFrameRate: i || 3 } }, r && (n.video.mandatory.maxWidth = r), o && (n.video.mandatory.maxHeight = o), e.navigator.mediaDevices.getUserMedia(n) })) } : console.error("shimGetDisplayMedia: getSourceId argument is not a function")) } function T(e) { e.MediaStream = e.MediaStream || e.webkitMediaStream } function S(e) { if ("object" == typeof e && e.RTCPeerConnection && !("ontrack" in e.RTCPeerConnection.prototype)) { Object.defineProperty(e.RTCPeerConnection.prototype, "ontrack", { get() { return this._ontrack }, set(e) { this._ontrack && this.removeEventListener("track", this._ontrack), this.addEventListener("track", this._ontrack = e) }, enumerable: !0, configurable: !0 }); const t = e.RTCPeerConnection.prototype.setRemoteDescription; e.RTCPeerConnection.prototype.setRemoteDescription = function () { return this._ontrackpoly || (this._ontrackpoly = t => { t.stream.addEventListener("addtrack", (n => { let r; r = e.RTCPeerConnection.prototype.getReceivers ? this.getReceivers().find((e => e.track && e.track.id === n.track.id)) : { track: n.track }; const o = new Event("track"); o.track = n.track, o.receiver = r, o.transceiver = { receiver: r }, o.streams = [t.stream], this.dispatchEvent(o) })), t.stream.getTracks().forEach((n => { let r; r = e.RTCPeerConnection.prototype.getReceivers ? this.getReceivers().find((e => e.track && e.track.id === n.id)) : { track: n }; const o = new Event("track"); o.track = n, o.receiver = r, o.transceiver = { receiver: r }, o.streams = [t.stream], this.dispatchEvent(o) })) }, this.addEventListener("addstream", this._ontrackpoly)), t.apply(this, arguments) } } else d(e, "track", (e => (e.transceiver || Object.defineProperty(e, "transceiver", { value: { receiver: e.receiver } }), e))) } function R(e) { if ("object" == typeof e && e.RTCPeerConnection && !("getSenders" in e.RTCPeerConnection.prototype) && "createDTMFSender" in e.RTCPeerConnection.prototype) { const t = function (e, t) { return { track: t, get dtmf() { return void 0 === this._dtmf && ("audio" === t.kind ? this._dtmf = e.createDTMFSender(t) : this._dtmf = null), this._dtmf }, _pc: e } }; if (!e.RTCPeerConnection.prototype.getSenders) { e.RTCPeerConnection.prototype.getSenders = function () { return this._senders = this._senders || [], this._senders.slice() }; const n = e.RTCPeerConnection.prototype.addTrack; e.RTCPeerConnection.prototype.addTrack = function (e, r) { let o = n.apply(this, arguments); return o || (o = t(this, e), this._senders.push(o)), o }; const r = e.RTCPeerConnection.prototype.removeTrack; e.RTCPeerConnection.prototype.removeTrack = function (e) { r.apply(this, arguments); const t = this._senders.indexOf(e); -1 !== t && this._senders.splice(t, 1) } } const n = e.RTCPeerConnection.prototype.addStream; e.RTCPeerConnection.prototype.addStream = function (e) { this._senders = this._senders || [], n.apply(this, [e]), e.getTracks().forEach((e => { this._senders.push(t(this, e)) })) }; const r = e.RTCPeerConnection.prototype.removeStream; e.RTCPeerConnection.prototype.removeStream = function (e) { this._senders = this._senders || [], r.apply(this, [e]), e.getTracks().forEach((e => { const t = this._senders.find((t => t.track === e)); t && this._senders.splice(this._senders.indexOf(t), 1) })) } } else if ("object" == typeof e && e.RTCPeerConnection && "getSenders" in e.RTCPeerConnection.prototype && "createDTMFSender" in e.RTCPeerConnection.prototype && e.RTCRtpSender && !("dtmf" in e.RTCRtpSender.prototype)) { const t = e.RTCPeerConnection.prototype.getSenders; e.RTCPeerConnection.prototype.getSenders = function () { const e = t.apply(this, []); return e.forEach((e => e._pc = this)), e }, Object.defineProperty(e.RTCRtpSender.prototype, "dtmf", { get() { return void 0 === this._dtmf && ("audio" === this.track.kind ? this._dtmf = this._pc.createDTMFSender(this.track) : this._dtmf = null), this._dtmf } }) } } function P(e) { if (!e.RTCPeerConnection) return; const t = e.RTCPeerConnection.prototype.getStats; e.RTCPeerConnection.prototype.getStats = function () { const [e, n, r] = arguments; if (arguments.length > 0 && "function" == typeof e) return t.apply(this, arguments); if (0 === t.length && (0 === arguments.length || "function" != typeof e)) return t.apply(this, []); const o = function (e) { const t = {}; return e.result().forEach((e => { const n = { id: e.id, timestamp: e.timestamp, type: { localcandidate: "local-candidate", remotecandidate: "remote-candidate" }[e.type] || e.type }; e.names().forEach((t => { n[t] = e.stat(t) })), t[n.id] = n })), t }, i = function (e) { return new Map(Object.keys(e).map((t => [t, e[t]]))) }; if (arguments.length >= 2) { const r = function (e) { n(i(o(e))) }; return t.apply(this, [r, e]) } return new Promise(((e, n) => { t.apply(this, [function (t) { e(i(o(t))) }, n]) })).then(n, r) } } function _(e) { if (!("object" == typeof e && e.RTCPeerConnection && e.RTCRtpSender && e.RTCRtpReceiver)) return; if (!("getStats" in e.RTCRtpSender.prototype)) { const t = e.RTCPeerConnection.prototype.getSenders; t && (e.RTCPeerConnection.prototype.getSenders = function () { const e = t.apply(this, []); return e.forEach((e => e._pc = this)), e }); const n = e.RTCPeerConnection.prototype.addTrack; n && (e.RTCPeerConnection.prototype.addTrack = function () { const e = n.apply(this, arguments); return e._pc = this, e }), e.RTCRtpSender.prototype.getStats = function () { const e = this; return this._pc.getStats().then((t => y(t, e.track, !0))) } } if (!("getStats" in e.RTCRtpReceiver.prototype)) { const t = e.RTCPeerConnection.prototype.getReceivers; t && (e.RTCPeerConnection.prototype.getReceivers = function () { const e = t.apply(this, []); return e.forEach((e => e._pc = this)), e }), d(e, "track", (e => (e.receiver._pc = e.srcElement, e))), e.RTCRtpReceiver.prototype.getStats = function () { const e = this; return this._pc.getStats().then((t => y(t, e.track, !1))) } } if (!("getStats" in e.RTCRtpSender.prototype) || !("getStats" in e.RTCRtpReceiver.prototype)) return; const t = e.RTCPeerConnection.prototype.getStats; e.RTCPeerConnection.prototype.getStats = function () { if (arguments.length > 0 && arguments[0] instanceof e.MediaStreamTrack) { const e = arguments[0]; let t, n, r; return this.getSenders().forEach((n => { n.track === e && (t ? r = !0 : t = n) })), this.getReceivers().forEach((t => (t.track === e && (n ? r = !0 : n = t), t.track === e))), r || t && n ? Promise.reject(new DOMException("There are more than one sender or receiver for the track.", "InvalidAccessError")) : t ? t.getStats() : n ? n.getStats() : Promise.reject(new DOMException("There is no sender or receiver for the track.", "InvalidAccessError")) } return t.apply(this, arguments) } } function k(e) { e.RTCPeerConnection.prototype.getLocalStreams = function () { return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, Object.keys(this._shimmedLocalStreams).map((e => this._shimmedLocalStreams[e][0])) }; const t = e.RTCPeerConnection.prototype.addTrack; e.RTCPeerConnection.prototype.addTrack = function (e, n) { if (!n) return t.apply(this, arguments); this._shimmedLocalStreams = this._shimmedLocalStreams || {}; const r = t.apply(this, arguments); return this._shimmedLocalStreams[n.id] ? -1 === this._shimmedLocalStreams[n.id].indexOf(r) && this._shimmedLocalStreams[n.id].push(r) : this._shimmedLocalStreams[n.id] = [n, r], r }; const n = e.RTCPeerConnection.prototype.addStream; e.RTCPeerConnection.prototype.addStream = function (e) { this._shimmedLocalStreams = this._shimmedLocalStreams || {}, e.getTracks().forEach((e => { if (this.getSenders().find((t => t.track === e))) throw new DOMException("Track already exists.", "InvalidAccessError") })); const t = this.getSenders(); n.apply(this, arguments); const r = this.getSenders().filter((e => -1 === t.indexOf(e))); this._shimmedLocalStreams[e.id] = [e].concat(r) }; const r = e.RTCPeerConnection.prototype.removeStream; e.RTCPeerConnection.prototype.removeStream = function (e) { return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, delete this._shimmedLocalStreams[e.id], r.apply(this, arguments) }; const o = e.RTCPeerConnection.prototype.removeTrack; e.RTCPeerConnection.prototype.removeTrack = function (e) { return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, e && Object.keys(this._shimmedLocalStreams).forEach((t => { const n = this._shimmedLocalStreams[t].indexOf(e); -1 !== n && this._shimmedLocalStreams[t].splice(n, 1), 1 === this._shimmedLocalStreams[t].length && delete this._shimmedLocalStreams[t] })), o.apply(this, arguments) } } function w(e, t) { if (!e.RTCPeerConnection) return; if (e.RTCPeerConnection.prototype.addTrack && t.version >= 65) return k(e); const n = e.RTCPeerConnection.prototype.getLocalStreams; e.RTCPeerConnection.prototype.getLocalStreams = function () { const e = n.apply(this); return this._reverseStreams = this._reverseStreams || {}, e.map((e => this._reverseStreams[e.id])) }; const r = e.RTCPeerConnection.prototype.addStream; e.RTCPeerConnection.prototype.addStream = function (t) { if (this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, t.getTracks().forEach((e => { if (this.getSenders().find((t => t.track === e))) throw new DOMException("Track already exists.", "InvalidAccessError") })), !this._reverseStreams[t.id]) { const n = new e.MediaStream(t.getTracks()); this._streams[t.id] = n, this._reverseStreams[n.id] = t, t = n } r.apply(this, [t]) }; const o = e.RTCPeerConnection.prototype.removeStream; function i(e, t) { let n = t.sdp; return Object.keys(e._reverseStreams || []).forEach((t => { const r = e._reverseStreams[t], o = e._streams[r.id]; n = n.replace(new RegExp(o.id, "g"), r.id) })), new RTCSessionDescription({ type: t.type, sdp: n }) } e.RTCPeerConnection.prototype.removeStream = function (e) { this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, o.apply(this, [this._streams[e.id] || e]), delete this._reverseStreams[this._streams[e.id] ? this._streams[e.id].id : e.id], delete this._streams[e.id] }, e.RTCPeerConnection.prototype.addTrack = function (t, n) { if ("closed" === this.signalingState) throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError"); const r = [].slice.call(arguments, 1); if (1 !== r.length || !r[0].getTracks().find((e => e === t))) throw new DOMException("The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.", "NotSupportedError"); if (this.getSenders().find((e => e.track === t))) throw new DOMException("Track already exists.", "InvalidAccessError"); this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}; const o = this._streams[n.id]; if (o) o.addTrack(t), Promise.resolve().then((() => { this.dispatchEvent(new Event("negotiationneeded")) })); else { const r = new e.MediaStream([t]); this._streams[n.id] = r, this._reverseStreams[r.id] = n, this.addStream(r) } return this.getSenders().find((e => e.track === t)) }, ["createOffer", "createAnswer"].forEach((function (t) { const n = e.RTCPeerConnection.prototype[t], r = { [t]() { const e = arguments; return arguments.length && "function" == typeof arguments[0] ? n.apply(this, [t => { const n = i(this, t); e[0].apply(null, [n]) }, t => { e[1] && e[1].apply(null, t) }, arguments[2]]) : n.apply(this, arguments).then((e => i(this, e))) } }; e.RTCPeerConnection.prototype[t] = r[t] })); const a = e.RTCPeerConnection.prototype.setLocalDescription; e.RTCPeerConnection.prototype.setLocalDescription = function () { return arguments.length && arguments[0].type ? (arguments[0] = function (e, t) { let n = t.sdp; return Object.keys(e._reverseStreams || []).forEach((t => { const r = e._reverseStreams[t], o = e._streams[r.id]; n = n.replace(new RegExp(r.id, "g"), o.id) })), new RTCSessionDescription({ type: t.type, sdp: n }) }(this, arguments[0]), a.apply(this, arguments)) : a.apply(this, arguments) }; const s = Object.getOwnPropertyDescriptor(e.RTCPeerConnection.prototype, "localDescription"); Object.defineProperty(e.RTCPeerConnection.prototype, "localDescription", { get() { const e = s.get.apply(this); return "" === e.type ? e : i(this, e) } }), e.RTCPeerConnection.prototype.removeTrack = function (e) { if ("closed" === this.signalingState) throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError"); if (!e._pc) throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.", "TypeError"); if (e._pc !== this) throw new DOMException("Sender was not created by this connection.", "InvalidAccessError"); let t; this._streams = this._streams || {}, Object.keys(this._streams).forEach((n => { this._streams[n].getTracks().find((t => e.track === t)) && (t = this._streams[n]) })), t && (1 === t.getTracks().length ? this.removeStream(this._reverseStreams[t.id]) : t.removeTrack(e.track), this.dispatchEvent(new Event("negotiationneeded"))) } } function E(e, t) { !e.RTCPeerConnection && e.webkitRTCPeerConnection && (e.RTCPeerConnection = e.webkitRTCPeerConnection), e.RTCPeerConnection && t.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach((function (t) { const n = e.RTCPeerConnection.prototype[t], r = { [t]() { return arguments[0] = new ("addIceCandidate" === t ? e.RTCIceCandidate : e.RTCSessionDescription)(arguments[0]), n.apply(this, arguments) } }; e.RTCPeerConnection.prototype[t] = r[t] })) } function x(e, t) { d(e, "negotiationneeded", (e => { const n = e.target; if (!(t.version < 72 || n.getConfiguration && "plan-b" === n.getConfiguration().sdpSemantics) || "stable" === n.signalingState) return e })) } function D(e, t) { const n = e && e.navigator, r = e && e.MediaStreamTrack; if (n.getUserMedia = function (e, t, r) { u("navigator.getUserMedia", "navigator.mediaDevices.getUserMedia"), n.mediaDevices.getUserMedia(e).then(t, r) }, !(t.version > 55 && "autoGainControl" in n.mediaDevices.getSupportedConstraints())) { const e = function (e, t, n) { t in e && !(n in e) && (e[n] = e[t], delete e[t]) }, t = n.mediaDevices.getUserMedia.bind(n.mediaDevices); if (n.mediaDevices.getUserMedia = function (n) { return "object" == typeof n && "object" == typeof n.audio && (n = JSON.parse(JSON.stringify(n)), e(n.audio, "autoGainControl", "mozAutoGainControl"), e(n.audio, "noiseSuppression", "mozNoiseSuppression")), t(n) }, r && r.prototype.getSettings) { const t = r.prototype.getSettings; r.prototype.getSettings = function () { const n = t.apply(this, arguments); return e(n, "mozAutoGainControl", "autoGainControl"), e(n, "mozNoiseSuppression", "noiseSuppression"), n } } if (r && r.prototype.applyConstraints) { const t = r.prototype.applyConstraints; r.prototype.applyConstraints = function (n) { return "audio" === this.kind && "object" == typeof n && (n = JSON.parse(JSON.stringify(n)), e(n, "autoGainControl", "mozAutoGainControl"), e(n, "noiseSuppression", "mozNoiseSuppression")), t.apply(this, [n]) } } } } function M(e, t) { e.navigator.mediaDevices && "getDisplayMedia" in e.navigator.mediaDevices || e.navigator.mediaDevices && (e.navigator.mediaDevices.getDisplayMedia = function (n) { if (!n || !n.video) { const e = new DOMException("getDisplayMedia without video constraints is undefined"); return e.name = "NotFoundError", e.code = 8, Promise.reject(e) } return !0 === n.video ? n.video = { mediaSource: t } : n.video.mediaSource = t, e.navigator.mediaDevices.getUserMedia(n) }) } function O(e) { "object" == typeof e && e.RTCTrackEvent && "receiver" in e.RTCTrackEvent.prototype && !("transceiver" in e.RTCTrackEvent.prototype) && Object.defineProperty(e.RTCTrackEvent.prototype, "transceiver", { get() { return { receiver: this.receiver } } }) } function I(e, t) { if ("object" != typeof e || !e.RTCPeerConnection && !e.mozRTCPeerConnection) return; !e.RTCPeerConnection && e.mozRTCPeerConnection && (e.RTCPeerConnection = e.mozRTCPeerConnection), t.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach((function (t) { const n = e.RTCPeerConnection.prototype[t], r = { [t]() { return arguments[0] = new ("addIceCandidate" === t ? e.RTCIceCandidate : e.RTCSessionDescription)(arguments[0]), n.apply(this, arguments) } }; e.RTCPeerConnection.prototype[t] = r[t] })); const n = { inboundrtp: "inbound-rtp", outboundrtp: "outbound-rtp", candidatepair: "candidate-pair", localcandidate: "local-candidate", remotecandidate: "remote-candidate" }, r = e.RTCPeerConnection.prototype.getStats; e.RTCPeerConnection.prototype.getStats = function () { const [e, o, i] = arguments; return r.apply(this, [e || null]).then((e => { if (t.version < 53 && !o) try { e.forEach((e => { e.type = n[e.type] || e.type })) } catch (t) { if ("TypeError" !== t.name) throw t; e.forEach(((t, r) => { e.set(r, Object.assign({}, t, { type: n[t.type] || t.type })) })) } return e })).then(o, i) } } function j(e) { if ("object" != typeof e || !e.RTCPeerConnection || !e.RTCRtpSender) return; if (e.RTCRtpSender && "getStats" in e.RTCRtpSender.prototype) return; const t = e.RTCPeerConnection.prototype.getSenders; t && (e.RTCPeerConnection.prototype.getSenders = function () { const e = t.apply(this, []); return e.forEach((e => e._pc = this)), e }); const n = e.RTCPeerConnection.prototype.addTrack; n && (e.RTCPeerConnection.prototype.addTrack = function () { const e = n.apply(this, arguments); return e._pc = this, e }), e.RTCRtpSender.prototype.getStats = function () { return this.track ? this._pc.getStats(this.track) : Promise.resolve(new Map) } } function L(e) { if ("object" != typeof e || !e.RTCPeerConnection || !e.RTCRtpSender) return; if (e.RTCRtpSender && "getStats" in e.RTCRtpReceiver.prototype) return; const t = e.RTCPeerConnection.prototype.getReceivers; t && (e.RTCPeerConnection.prototype.getReceivers = function () { const e = t.apply(this, []); return e.forEach((e => e._pc = this)), e }), d(e, "track", (e => (e.receiver._pc = e.srcElement, e))), e.RTCRtpReceiver.prototype.getStats = function () { return this._pc.getStats(this.track) } } function A(e) { e.RTCPeerConnection && !("removeStream" in e.RTCPeerConnection.prototype) && (e.RTCPeerConnection.prototype.removeStream = function (e) { u("removeStream", "removeTrack"), this.getSenders().forEach((t => { t.track && e.getTracks().includes(t.track) && this.removeTrack(t) })) }) } function N(e) { e.DataChannel && !e.RTCDataChannel && (e.RTCDataChannel = e.DataChannel) } function F(e) { if ("object" != typeof e || !e.RTCPeerConnection) return; const t = e.RTCPeerConnection.prototype.addTransceiver; t && (e.RTCPeerConnection.prototype.addTransceiver = function () { this.setParametersPromises = []; let e = arguments[1] && arguments[1].sendEncodings; void 0 === e && (e = []), e = [...e]; const n = e.length > 0; n && e.forEach((e => { if ("rid" in e && !/^[a-z0-9]{0,16}$/i.test(e.rid)) throw new TypeError("Invalid RID value provided."); if ("scaleResolutionDownBy" in e && !(parseFloat(e.scaleResolutionDownBy) >= 1)) throw new RangeError("scale_resolution_down_by must be >= 1.0"); if ("maxFramerate" in e && !(parseFloat(e.maxFramerate) >= 0)) throw new RangeError("max_framerate must be >= 0.0") })); const r = t.apply(this, arguments); if (n) { const { sender: t } = r, n = t.getParameters(); (!("encodings" in n) || 1 === n.encodings.length && 0 === Object.keys(n.encodings[0]).length) && (n.encodings = e, t.sendEncodings = e, this.setParametersPromises.push(t.setParameters(n).then((() => { delete t.sendEncodings })).catch((() => { delete t.sendEncodings })))) } return r }) } function U(e) { if ("object" != typeof e || !e.RTCRtpSender) return; const t = e.RTCRtpSender.prototype.getParameters; t && (e.RTCRtpSender.prototype.getParameters = function () { const e = t.apply(this, arguments); return "encodings" in e || (e.encodings = [].concat(this.sendEncodings || [{}])), e }) } function z(e) { if ("object" != typeof e || !e.RTCPeerConnection) return; const t = e.RTCPeerConnection.prototype.createOffer; e.RTCPeerConnection.prototype.createOffer = function () { return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then((() => t.apply(this, arguments))).finally((() => { this.setParametersPromises = [] })) : t.apply(this, arguments) } } function G(e) { if ("object" != typeof e || !e.RTCPeerConnection) return; const t = e.RTCPeerConnection.prototype.createAnswer; e.RTCPeerConnection.prototype.createAnswer = function () { return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then((() => t.apply(this, arguments))).finally((() => { this.setParametersPromises = [] })) : t.apply(this, arguments) } } function J(e) { if ("object" == typeof e && e.RTCPeerConnection) { if ("getLocalStreams" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.getLocalStreams = function () { return this._localStreams || (this._localStreams = []), this._localStreams }), !("addStream" in e.RTCPeerConnection.prototype)) { const t = e.RTCPeerConnection.prototype.addTrack; e.RTCPeerConnection.prototype.addStream = function (e) { this._localStreams || (this._localStreams = []), this._localStreams.includes(e) || this._localStreams.push(e), e.getAudioTracks().forEach((n => t.call(this, n, e))), e.getVideoTracks().forEach((n => t.call(this, n, e))) }, e.RTCPeerConnection.prototype.addTrack = function (e, ...n) { return n && n.forEach((e => { this._localStreams ? this._localStreams.includes(e) || this._localStreams.push(e) : this._localStreams = [e] })), t.apply(this, arguments) } } "removeStream" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.removeStream = function (e) { this._localStreams || (this._localStreams = []); const t = this._localStreams.indexOf(e); if (-1 === t) return; this._localStreams.splice(t, 1); const n = e.getTracks(); this.getSenders().forEach((e => { n.includes(e.track) && this.removeTrack(e) })) }) } } function V(e) { if ("object" == typeof e && e.RTCPeerConnection && ("getRemoteStreams" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.getRemoteStreams = function () { return this._remoteStreams ? this._remoteStreams : [] }), !("onaddstream" in e.RTCPeerConnection.prototype))) { Object.defineProperty(e.RTCPeerConnection.prototype, "onaddstream", { get() { return this._onaddstream }, set(e) { this._onaddstream && (this.removeEventListener("addstream", this._onaddstream), this.removeEventListener("track", this._onaddstreampoly)), this.addEventListener("addstream", this._onaddstream = e), this.addEventListener("track", this._onaddstreampoly = e => { e.streams.forEach((e => { if (this._remoteStreams || (this._remoteStreams = []), this._remoteStreams.includes(e)) return; this._remoteStreams.push(e); const t = new Event("addstream"); t.stream = e, this.dispatchEvent(t) })) }) } }); const t = e.RTCPeerConnection.prototype.setRemoteDescription; e.RTCPeerConnection.prototype.setRemoteDescription = function () { const e = this; return this._onaddstreampoly || this.addEventListener("track", this._onaddstreampoly = function (t) { t.streams.forEach((t => { if (e._remoteStreams || (e._remoteStreams = []), e._remoteStreams.indexOf(t) >= 0) return; e._remoteStreams.push(t); const n = new Event("addstream"); n.stream = t, e.dispatchEvent(n) })) }), t.apply(e, arguments) } } } function B(e) { if ("object" != typeof e || !e.RTCPeerConnection) return; const t = e.RTCPeerConnection.prototype, n = t.createOffer, r = t.createAnswer, o = t.setLocalDescription, i = t.setRemoteDescription, a = t.addIceCandidate; t.createOffer = function (e, t) { const r = arguments.length >= 2 ? arguments[2] : arguments[0], o = n.apply(this, [r]); return t ? (o.then(e, t), Promise.resolve()) : o }, t.createAnswer = function (e, t) { const n = arguments.length >= 2 ? arguments[2] : arguments[0], o = r.apply(this, [n]); return t ? (o.then(e, t), Promise.resolve()) : o }; let s = function (e, t, n) { const r = o.apply(this, [e]); return n ? (r.then(t, n), Promise.resolve()) : r }; t.setLocalDescription = s, s = function (e, t, n) { const r = i.apply(this, [e]); return n ? (r.then(t, n), Promise.resolve()) : r }, t.setRemoteDescription = s, s = function (e, t, n) { const r = a.apply(this, [e]); return n ? (r.then(t, n), Promise.resolve()) : r }, t.addIceCandidate = s } function K(e) { const t = e && e.navigator; if (t.mediaDevices && t.mediaDevices.getUserMedia) { const e = t.mediaDevices, n = e.getUserMedia.bind(e); t.mediaDevices.getUserMedia = e => n(W(e)) } !t.getUserMedia && t.mediaDevices && t.mediaDevices.getUserMedia && (t.getUserMedia = function (e, n, r) { t.mediaDevices.getUserMedia(e).then(n, r) }.bind(t)) } function W(e) { return e && void 0 !== e.video ? Object.assign({}, e, { video: m(e.video) }) : e } function $(e) { if (!e.RTCPeerConnection) return; const t = e.RTCPeerConnection; e.RTCPeerConnection = function (e, n) { if (e && e.iceServers) { const t = []; for (let n = 0; n < e.iceServers.length; n++) { let r = e.iceServers[n]; !r.hasOwnProperty("urls") && r.hasOwnProperty("url") ? (u("RTCIceServer.url", "RTCIceServer.urls"), r = JSON.parse(JSON.stringify(r)), r.urls = r.url, delete r.url, t.push(r)) : t.push(e.iceServers[n]) } e.iceServers = t } return new t(e, n) }, e.RTCPeerConnection.prototype = t.prototype, "generateCertificate" in t && Object.defineProperty(e.RTCPeerConnection, "generateCertificate", { get: () => t.generateCertificate }) } function q(e) { "object" == typeof e && e.RTCTrackEvent && "receiver" in e.RTCTrackEvent.prototype && !("transceiver" in e.RTCTrackEvent.prototype) && Object.defineProperty(e.RTCTrackEvent.prototype, "transceiver", { get() { return { receiver: this.receiver } } }) } function H(e) { const t = e.RTCPeerConnection.prototype.createOffer; e.RTCPeerConnection.prototype.createOffer = function (e) { if (e) { void 0 !== e.offerToReceiveAudio && (e.offerToReceiveAudio = !!e.offerToReceiveAudio); const t = this.getTransceivers().find((e => "audio" === e.receiver.track.kind)); !1 === e.offerToReceiveAudio && t ? "sendrecv" === t.direction ? t.setDirection ? t.setDirection("sendonly") : t.direction = "sendonly" : "recvonly" === t.direction && (t.setDirection ? t.setDirection("inactive") : t.direction = "inactive") : !0 !== e.offerToReceiveAudio || t || this.addTransceiver("audio", { direction: "recvonly" }), void 0 !== e.offerToReceiveVideo && (e.offerToReceiveVideo = !!e.offerToReceiveVideo); const n = this.getTransceivers().find((e => "video" === e.receiver.track.kind)); !1 === e.offerToReceiveVideo && n ? "sendrecv" === n.direction ? n.setDirection ? n.setDirection("sendonly") : n.direction = "sendonly" : "recvonly" === n.direction && (n.setDirection ? n.setDirection("inactive") : n.direction = "inactive") : !0 !== e.offerToReceiveVideo || n || this.addTransceiver("video", { direction: "recvonly" }) } return t.apply(this, arguments) } } function Y(e) { "object" != typeof e || e.AudioContext || (e.AudioContext = e.webkitAudioContext) } var X = a(20597), Q = a.n(X); function Z(e) { if (!e.RTCIceCandidate || e.RTCIceCandidate && "foundation" in e.RTCIceCandidate.prototype) return; const t = e.RTCIceCandidate; e.RTCIceCandidate = function (e) { if ("object" == typeof e && e.candidate && 0 === e.candidate.indexOf("a=") && ((e = JSON.parse(JSON.stringify(e))).candidate = e.candidate.substr(2)), e.candidate && e.candidate.length) { const n = new t(e), r = Q().parseCandidate(e.candidate), o = Object.assign(n, r); return o.toJSON = function () { return { candidate: o.candidate, sdpMid: o.sdpMid, sdpMLineIndex: o.sdpMLineIndex, usernameFragment: o.usernameFragment } }, o } return new t(e) }, e.RTCIceCandidate.prototype = t.prototype, d(e, "icecandidate", (t => (t.candidate && Object.defineProperty(t, "candidate", { value: new e.RTCIceCandidate(t.candidate), writable: "false" }), t))) } function ee(e) { !e.RTCIceCandidate || e.RTCIceCandidate && "relayProtocol" in e.RTCIceCandidate.prototype || d(e, "icecandidate", (e => { if (e.candidate) { const t = Q().parseCandidate(e.candidate.candidate); "relay" === t.type && (e.candidate.relayProtocol = { 0: "tls", 1: "tcp", 2: "udp" }[t.priority >> 24]) } return e })) } function te(e, t) { if (!e.RTCPeerConnection) return; "sctp" in e.RTCPeerConnection.prototype || Object.defineProperty(e.RTCPeerConnection.prototype, "sctp", { get() { return void 0 === this._sctp ? null : this._sctp } }); const n = e.RTCPeerConnection.prototype.setRemoteDescription; e.RTCPeerConnection.prototype.setRemoteDescription = function () { if (this._sctp = null, "chrome" === t.browser && t.version >= 76) { const { sdpSemantics: e } = this.getConfiguration(); "plan-b" === e && Object.defineProperty(this, "sctp", { get() { return void 0 === this._sctp ? null : this._sctp }, enumerable: !0, configurable: !0 }) } if (function (e) { if (!e || !e.sdp) return !1; const t = Q().splitSections(e.sdp); return t.shift(), t.some((e => { const t = Q().parseMLine(e); return t && "application" === t.kind && -1 !== t.protocol.indexOf("SCTP") })) }(arguments[0])) { const e = function (e) { const t = e.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/); if (null === t || t.length < 2) return -1; const n = parseInt(t[1], 10); return n != n ? -1 : n }(arguments[0]), n = function (e) { let n = 65536; return "firefox" === t.browser && (n = t.version < 57 ? -1 === e ? 16384 : 2147483637 : t.version < 60 ? 57 === t.version ? 65535 : 65536 : 2147483637), n }(e), r = function (e, n) { let r = 65536; "firefox" === t.browser && 57 === t.version && (r = 65535); const o = Q().matchPrefix(e.sdp, "a=max-message-size:"); return o.length > 0 ? r = parseInt(o[0].substr(19), 10) : "firefox" === t.browser && -1 !== n && (r = 2147483637), r }(arguments[0], e); let o; o = 0 === n && 0 === r ? Number.POSITIVE_INFINITY : 0 === n || 0 === r ? Math.max(n, r) : Math.min(n, r); const i = {}; Object.defineProperty(i, "maxMessageSize", { get: () => o }), this._sctp = i } return n.apply(this, arguments) } } function ne(e) { if (!e.RTCPeerConnection || !("createDataChannel" in e.RTCPeerConnection.prototype)) return; function t(e, t) { const n = e.send; e.send = function () { const r = arguments[0], o = r.length || r.size || r.byteLength; if ("open" === e.readyState && t.sctp && o > t.sctp.maxMessageSize) throw new TypeError("Message too large (can send a maximum of " + t.sctp.maxMessageSize + " bytes)"); return n.apply(e, arguments) } } const n = e.RTCPeerConnection.prototype.createDataChannel; e.RTCPeerConnection.prototype.createDataChannel = function () { const e = n.apply(this, arguments); return t(e, this), e }, d(e, "datachannel", (e => (t(e.channel, e.target), e))) } function re(e) { if (!e.RTCPeerConnection || "connectionState" in e.RTCPeerConnection.prototype) return; const t = e.RTCPeerConnection.prototype; Object.defineProperty(t, "connectionState", { get() { return { completed: "connected", checking: "connecting" }[this.iceConnectionState] || this.iceConnectionState }, enumerable: !0, configurable: !0 }), Object.defineProperty(t, "onconnectionstatechange", { get() { return this._onconnectionstatechange || null }, set(e) { this._onconnectionstatechange && (this.removeEventListener("connectionstatechange", this._onconnectionstatechange), delete this._onconnectionstatechange), e && this.addEventListener("connectionstatechange", this._onconnectionstatechange = e) }, enumerable: !0, configurable: !0 }), ["setLocalDescription", "setRemoteDescription"].forEach((e => { const n = t[e]; t[e] = function () { return this._connectionstatechangepoly || (this._connectionstatechangepoly = e => { const t = e.target; if (t._lastConnectionState !== t.connectionState) { t._lastConnectionState = t.connectionState; const n = new Event("connectionstatechange", e); t.dispatchEvent(n) } return e }, this.addEventListener("iceconnectionstatechange", this._connectionstatechangepoly)), n.apply(this, arguments) } })) } function oe(e, t) { if (!e.RTCPeerConnection) return; if ("chrome" === t.browser && t.version >= 71) return; if ("safari" === t.browser && t.version >= 605) return; const n = e.RTCPeerConnection.prototype.setRemoteDescription; e.RTCPeerConnection.prototype.setRemoteDescription = function (t) { if (t && t.sdp && -1 !== t.sdp.indexOf("\na=extmap-allow-mixed")) { const n = t.sdp.split("\n").filter((e => "a=extmap-allow-mixed" !== e.trim())).join("\n"); e.RTCSessionDescription && t instanceof e.RTCSessionDescription ? arguments[0] = new e.RTCSessionDescription({ type: t.type, sdp: n }) : t.sdp = n } return n.apply(this, arguments) } } function ie(e, t) { if (!e.RTCPeerConnection || !e.RTCPeerConnection.prototype) return; const n = e.RTCPeerConnection.prototype.addIceCandidate; n && 0 !== n.length && (e.RTCPeerConnection.prototype.addIceCandidate = function () { return arguments[0] ? ("chrome" === t.browser && t.version < 78 || "firefox" === t.browser && t.version < 68 || "safari" === t.browser) && arguments[0] && "" === arguments[0].candidate ? Promise.resolve() : n.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), Promise.resolve()) }) } function ae(e, t) { if (!e.RTCPeerConnection || !e.RTCPeerConnection.prototype) return; const n = e.RTCPeerConnection.prototype.setLocalDescription; n && 0 !== n.length && (e.RTCPeerConnection.prototype.setLocalDescription = function () { let e = arguments[0] || {}; if ("object" != typeof e || e.type && e.sdp) return n.apply(this, arguments); if (e = { type: e.type, sdp: e.sdp }, !e.type) switch (this.signalingState) { case "stable": case "have-local-offer": case "have-remote-pranswer": e.type = "offer"; break; default: e.type = "answer" }return e.sdp || "offer" !== e.type && "answer" !== e.type ? n.apply(this, [e]) : ("offer" === e.type ? this.createOffer : this.createAnswer).apply(this).then((e => n.apply(this, [e]))) }) } !function ({ window: o } = {}, i = { shimChrome: !0, shimFirefox: !0, shimSafari: !0 }) { const a = l, s = function (e) { const t = { browser: null, version: null }; if (void 0 === e || !e.navigator) return t.browser = "Not a browser.", t; const { navigator: n } = e; if (n.mozGetUserMedia) t.browser = "firefox", t.version = c(n.userAgent, /Firefox\/(\d+)\./, 1); else if (n.webkitGetUserMedia || !1 === e.isSecureContext && e.webkitRTCPeerConnection) t.browser = "chrome", t.version = c(n.userAgent, /Chrom(e|ium)\/(\d+)\./, 2); else { if (!e.RTCPeerConnection || !n.userAgent.match(/AppleWebKit\/(\d+)\./)) return t.browser = "Not a supported browser.", t; t.browser = "safari", t.version = c(n.userAgent, /AppleWebKit\/(\d+)\./, 1), t.supportsUnifiedPlan = e.RTCRtpTransceiver && "currentDirection" in e.RTCRtpTransceiver.prototype } return t }(o), d = { browserDetails: s, commonShim: r, extractVersion: c, disableLog: p, disableWarnings: f, sdp: X }; switch (s.browser) { case "chrome": if (!e || !E || !i.shimChrome) return a("Chrome shim is not included in this adapter release."), d; if (null === s.version) return a("Chrome shim can not determine version, not shimming."), d; a("adapter.js shimming chrome."), d.browserShim = e, ie(o, s), ae(o), g(o, s), T(o), E(o, s), S(o), w(o, s), R(o), P(o), _(o), x(o, s), Z(o), ee(o), re(o), te(o, s), ne(o), oe(o, s); break; case "firefox": if (!t || !I || !i.shimFirefox) return a("Firefox shim is not included in this adapter release."), d; a("adapter.js shimming firefox."), d.browserShim = t, ie(o, s), ae(o), D(o, s), I(o, s), O(o), A(o), j(o), L(o), N(o), F(o), U(o), z(o), G(o), Z(o), re(o), te(o, s), ne(o); break; case "safari": if (!n || !i.shimSafari) return a("Safari shim is not included in this adapter release."), d; a("adapter.js shimming safari."), d.browserShim = n, ie(o, s), ae(o), $(o), H(o), B(o), J(o), V(o), q(o), K(o), Y(o), Z(o), ee(o), te(o, s), ne(o), oe(o, s); break; default: a("Unsupported browser!") } }({ window: "undefined" == typeof window ? void 0 : window }), a.p = `${window.duo.static_root}/`, window.duo.sourcesPromise.then((() => { Promise.all([a.e(1721), a.e(7803), a.e(1806), a.e(5193)]).then(a.bind(a, 36218)), (0, o.Au)() && (Promise.all([a.e(1721), a.e(1806), a.e(3330)]).then(a.bind(a, 30487)), Promise.all([a.e(1721), a.e(1806), a.e(3330)]).then(a.bind(a, 63355))) })) })() })();
//# sourceMappingURL=main_prod_01027e61470a9de3be92.js.map